searchState.loadedDescShard("storage_proofs_core", 0, "The ApiFeature enum is used for optional features that the …\nThe ApiVersion enum is used for mandatory changes that the …\nReturn the features that are in conflict with the current …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCircuitComponent exists so parent components can pass …\nThe CompoundProof trait bundles a proof::ProofScheme and a …\nGiven a prover_srs key, a list of groth16 proofs, and an …\nEfficiently verify multiple proofs.\ncircuit constructs an instance of this CompoundProof’s …\nLike circuit_for_test but returns values for all …\ncircuit_proof creates and synthesizes a circuit from …\nReturns the argument unchanged.\nReturns the argument unchanged.\ngenerate_public_inputs generates public inputs suitable …\nIf the rng option argument is set, parameters will be …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHigh priority (always runs on GPU) == true\nprove is equivalent to ProofScheme::prove.\nIf the rng option argument is set, parameters will be …\nIf the rng option argument is set, parameters will be …\nVerifies the aggregate proof, with respect to the …\nIf the rng option argument is set, parameters will be …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSloth based decoding.\nSloth based encoding.\nDecodes ciphertext by elementwise xoring with the passed …\nEncodes plaintext by elementwise xoring with the passed in …\nA wrapper around data either on disk or a slice in memory, …\nDrops the actual data, if we can recover it.\nRecover the data.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe base degree used for all DRG graphs. One degree from …\nBucket sampling algorithm.\nA depth robust graph.\nCreates the encoding key. The algorithm for that is …\nReturns the number of parents of each node in the graph.\nReturns the degree of the graph.\nReturns the expected size of all nodes in the graph.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the merkle tree depth.\nReturns a sorted list of all parents of this node. The …\nReturns the size of the graph (number of nodes).\nContains the error value\nCustom error types\nContains the success value\n<code>Result&lt;T, Error&gt;</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInsertion Permutation\nAdds a constraint to CS, enforcing a difference …\nAdds a constraint to CS, enforcing an equality …\nAdds a constraint to CS, enforcing a add relationship …\nInsert <code>element</code> after the nth 1-indexed element of <code>elements</code>…\nTakes two allocated numbers (<code>a</code>, <code>b</code>) and returns <code>a</code> if the …\nSelect the nth element of <code>from</code>, where <code>path_bits</code> represents …\nProof of retrievability.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSynthesizes a PoR proof without adding a public input for …\nPublic Inputs\nRepresents an interpretation of 64 <code>Boolean</code> objects as an …\nAllocate a <code>UInt64</code> in the constraint system\nConstruct a constant <code>UInt64</code> from a <code>u64</code>\nReturns the argument unchanged.\nConverts a little-endian byte order representation of bits …\nCalls <code>U::from(self)</code>.\nTurns this <code>UInt64</code> into its little-endian byte order …\nRoot represents a root commitment which may be either a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA binary merkle tree, where all levels have arity 2. It’…\nThe Disk-only store is used to reduce memory to the …\nA tree that is fully persisted to disk.\nA tree that is partially stored on disk, some levels are …\nRepresentation of a merkle proof.\nTrait to abstract over the concept of Merkle Proof.\nTrait used to abstract over the way Merkle Trees are …\nBacking store of the merkle tree.\nConstruct a new level cache merkle tree, given the …\nPrint a unique name for this configuration.\nCalcluates the exected length of the full path, given the …\nCalcluates the exected length of the full path, given the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a merkle proof of the node at the given index.\nOnly used for testing, but can’t cfg-test it as that …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis constructor is used for instantiating stores ONLY …\nCreates a new store which can store up to <code>size</code> elements.\nReturns the root hash of the tree.\nCalculate the root of this path, given the leaf as input.\nTry to convert a merkletree proof into this structure.\nValidates the MerkleProof and that it corresponds to the …\nValidates the MerkleProof and that it corresponds to the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBump this when circuits change to invalidate the cache.\nQAP “A” polynomials evaluated at tau in the Lagrange …\nQAP “B” polynomials evaluated at tau in the Lagrange …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf the rng option argument is set, parameters will be …\nIf the rng option argument is set, parameters will be …\nGet the correct parameter data for a given cache id.\nGet the correct parameter data for a given cache id.\nGet the correct srs parameter data for a given cache id.\nIf the rng option argument is set, parameters will be …\nGet the correct verifying key data for a given cache id.\nElements of the form ((tau^i * t(tau)) / delta) for i …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nElements of the form (beta * u_i(tau) + alpha v_i(tau) + …\nThe file descriptor we have mmaped.\nThe parameter file we’re reading from.\nThe actual mmap.\nReads parameter from parameter cache.\nThis is always loaded (i.e. not lazily loaded).\nNo value.\nSome value of type <code>T</code>.\n<code>position</code>, <code>length</code> are in H::Domain units\n<code>compute_packing</code> returns a packing list and a proof size. A …\nReturns the argument unchanged.\nGenerate <code>comm_p</code> from a source and return it as bytes.\nCalls <code>U::from(self)</code>.\nMerkle tree based proof of retrievability.\nThe inputs that are only available to the prover.\nThe inputs that are necessary for the verifier to verify …\nThe parameters shared between the prover and verifier.\nThe challenge, which leaf to prove.\nThe root hash of the underlying merkle tree.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe data of the leaf.\nHow many leaves the underlying merkle tree has.\nThe underlying merkle tree.\nThe ProofScheme trait provides the methods that any proof …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nprove generates and returns a proof from public …\nsetup is used to generate public parameters from setup …\nverify returns true if the supplied proof is valid for the …\nAn ordered set of <code>SectorId</code>s.\nIdentifier for a single sector.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts a slice of bools into their byte representation, …\nConverts bytes into their bit representation, in little …\nConverts bytes into their bit representation, in big …\nConverts bytes into their bit representation, in little …\nConverts the bytes into a boolean vector, in little endian …\nConverts the bytes into a boolean vector, in big endian …\nReturns the byte slice representing one node (of uniform …\nReturns the start position of the data, 0-indexed.\nReverse the order of bits within each byte (bit …")