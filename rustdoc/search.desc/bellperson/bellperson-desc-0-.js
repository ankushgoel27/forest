searchState.loadedDescShard("bellperson", 0, "<code>bellperson</code> is a crate for building zk-SNARK circuits. It …\nDuring synthesis, we lacked knowledge of a variable …\nComputations are expressed in terms of arithmetic …\nRepresents a constraint system which can have new variables\nDuring synthesis, we divided by zero.\nRepresents the index of either an input variable or …\nDuring proof generation, we encountered an I/O error with …\nThis represents a linear combination of some variables, …\nDuring GPU multiexp/fft, some GPU related error happened\nDuring verification, our verifying key was malformed.\nThis is a “namespaced” constraint system which borrows …\nDuring synthesis, our polynomials ended up being too high …\nRepresents the type of the “root” of this constraint …\nThis is an error that could occur during circuit synthesis …\nDuring CRS generation, we observed an unconstrained …\nDuring proof generation, we encountered an identity in the …\nDuring synthesis, we constructed an unsatisfiable …\nRepresents a variable in our constraint system.\nAllocate a private variable in the constraint system. The …\nAllocate a public variable in the constraint system. The …\nAllocate empty space for the auxiliary inputs and the main …\nAllocate empty space for the auxiliary inputs of the …\nAllocate empty space for the main inputs of the …\nReturns the constraint system’s aux witness as a slice …\nThis module contains an <code>EvaluationDomain</code> abstraction for …\nEnforce that <code>A</code> * <code>B</code> = <code>C</code>. The <code>annotation</code> function is invoked …\nExtend concatenates thew  <code>other</code> constraint systems to the …\nExtend the auxiliary inputs of the <code>ConstraintSystem</code>.\nExtend the inputs of the <code>ConstraintSystem</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSelf-contained sub-circuit implementations for various …\nGets the “root” constraint system, bypassing the …\nThis returns the index underlying the variable. Circuit …\nThe Groth16 proving system.\nReturns the constraint system’s inputs as a slice of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMost implementations of ConstraintSystem are not ‘…\nDetermines if the current <code>ConstraintSystem</code> instance is a …\nBegin a namespace for this constraint system.\nThis constructs a variable with an arbitrary index. …\nReturn the “one” input variable\nExit out of the existing namespace. Not intended for …\nCreate a new (sub)namespace and enter into it. Not intended\nSynthesize the circuit into a rank-1 quadratic constraint …\nExecute three Coset FFTs in parallel.\nThe target polynomial is the zero polynomial in our …\nExecute three FFTs in parallel.\nReturns the argument unchanged.\nExecute multiple IFFTs in parallel.\nCalls <code>U::from(self)</code>.\nPerform O(n) multiplication of two polynomials in the …\nPerform O(n) subtraction of one polynomial from another in …\nThis evaluates t(tau) for this domain, which is tau^m - 1 …\nThis basically is just an extension to <code>Option</code> which allows …\nThe BLAKE2s hash function with personalization support.\nGadgets for allocating bits in the circuit and performing …\nWindow table lookup gadgets.\nHelpers for packing vectors of bits into scalar field …\nGadgets representing numbers in the scalar field of the …\nCircuits for the SHA-256 hash function and its internal …\nHelpers for testing circuit implementations.\nCircuit representation of a <code>u32</code>, with helpers for the […\nRepresents a variable in the constraint system which is …\nThis is a boolean value which may be either a constant or …\nConstant (not an allocated variable)\nExistential view of the boolean variable\nNegated view of the boolean variable\nAllocate a variable in the constraint system which can …\nAllocate a variable in the constraint system which can …\nPerforms an AND operation over the two operands, returning …\nPerform AND over two boolean operands\nCalculates <code>a AND (NOT b)</code>.\nConstruct a boolean from a known constant\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalculates <code>(NOT a) AND (NOT b)</code>.\nReturn a negated interpretation of this boolean.\nComputes (a and b) xor ((not a) and c)\nComputes (a and b) xor (a and c) xor (b and c)\nPerforms an XOR operation over the two operands, returning …\nPerform XOR over two boolean operands\nPerforms a 3-bit window table lookup. <code>bits</code> is in …\nPerforms a 3-bit window table lookup, where one of the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTakes a sequence of booleans and exposes them as a single …\nTakes a sequence of booleans and exposes them as compact …\nAllocate a <code>Variable(Aux)</code> in a <code>ConstraintSystem</code>.\nAllocate a <code>Variable(Input)</code> in a <code>ConstraintSystem</code>.\nAllocate a <code>Variable</code> of either <code>Aux</code> or <code>Input</code> in a …\nTakes two allocated numbers (a, b) and returns (b, a) if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the allocated number into its little-endian …\nDeconstructs this allocated number into its boolean …\nConstraint system for testing purposes.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRepresents an interpretation of 32 <code>Boolean</code> objects as an …\nPerform modular addition of several <code>UInt32</code> objects.\nAllocate a <code>UInt32</code> in the constraint system\nConstruct a constant <code>UInt32</code> from a <code>u32</code>\nReturns the argument unchanged.\nConverts a little-endian byte order representation of bits …\nCalls <code>U::from(self)</code>.\nTurns this <code>UInt32</code> into its little-endian byte order …\nCompute the <code>ch</code> value <code>(a and b) xor ((not a) and c)</code> during …\nCompute the <code>maj</code> value (a and b) xor (a and c) xor (b and c)\nXOR this <code>UInt32</code> with another <code>UInt32</code>\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nQAP “A” polynomials evaluated at tau in the Lagrange …\nQAP “B” polynomials evaluated at tau in the Lagrange …\nCreates a single proof where the randomization vector is …\nCreates a batch of proofs where the randomization vector …\nCreates a batch of proofs where the randomization vector …\nCreates a single proof. When several proofs are run in …\nCreates a single proof.\nCreates a batch of proofs.\nCreates a batch of proofs. When several proofs are run in …\nCreates a batch of proofs. When several proofs are run in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate parameters for a circuit, given some toxic waste.\nGenerates a random common reference string for a circuit.\nElements of the form ((tau^i * t(tau)) / delta) for i …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nElements of the form (beta * u_i(tau) + alpha v_i(tau) + …\nThe file descriptor we have mmaped.\nThe parameter file we’re reading from.\nThe actual mmap.\nGenerate a prepared verifying key, required to verify a …\nVerify a single Proof.\nRandomized batch verification - see Appendix B.2 in Zcash …\nThis is always loaded (i.e. not lazily loaded).\nAggregateProof contains all elements to verify n …\nIt contains the maximum number of raw elements of the SRS …\nIt contains all elements derived in the GIPA loop for both …\nKZGOpening represents the KZG opening of a commitment key …\nKey is a generic commitment key that is instanciated with …\nMaximum size of the generic SRS constructed from Filecoin …\nBoth commitment outputs a pair of $F_q^k$ element.\nProverSRS is the specialized SRS version for the prover …\nProverSRS is the specialized SRS version for the prover …\nIt contains the GIPA recursive elements as well as the KZG …\nCommitment key used by the “single” commitment on G1 …\nContains the necessary elements to verify an aggregated …\nCommitment key used by the “pair” commitment. Note the …\nExponent is a\nExponent is a\nExponent is a\n$C^r$ is used on the right side of the aggregated Groth16 …\nAggregate <code>n</code> zkSnark proofs, where <code>n</code> must be a power of two.\nExponent is b\nExponent is b\nExponent is b\ncommitment to A and B using the pair commitment scheme …\ncommit to C separate since we use it only in MIPP\nTakes a left and right commitment key and returns a …\nfinal commitment keys $v$ and $w$ - there is only one …\nReturns the first values in the vector of v1 and v2 …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n${g^a^i}_{i=0}^{N}$ where N is the smallest size of the …\nNeeded for optimized input aggregation\n${g^a^i}_{i=0}^{2n-1}$ where n is the number of proofs to …\n${g^b^i}_{i=n}^{N}$ where N is the smallest size of the …\n${g^b^i}_{i=0}^{2n-1}$\n${h^a^i}_{i=0}^{N}$ where N is the smallest size of the …\n${h^a^i}_{i=0}^{n-1}$ - here we don’t need to go to 2n-1 …\n${h^b^i}_{i=0}^{N}$ where N is the smallest size of the …\n${h^b^i}_{i=0}^{n-1}$\nReturns true if commitment keys have the exact required …\nReturns true if commitment keys have the exact required …\nReturns true if commitment keys have the exact required …\nReturns the hash over all powers of this generic srs.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n$A^r * B = Z$ is the left value on the aggregated Groth16 …\nnumber of proofs to aggregate\nCommits to a tuple of G1 vector and G2 vector in the …\nPerforms some high level checks on the length of vectors …\nReturns both vectors scaled by the given vector entrywise. …\nReturns the number of bytes this proof is serialized to.\nCommits to a single vector of G1 elements in the following …\nReturns the prover and verifier SRS for a specific number …\nReturns the prover and verifier SRS for a specific number …\nReturns the left and right commitment key part. It makes …\nVerifies the aggregated proofs thanks to the Groth16 …\nverification of related instances i.e. when instances are …\nverify_kzg_opening_g2 takes a KZG opening, the final …\nSimilar to verify_kzg_opening_g2 but for g1.\ncommitment key using in MIPP and TIPP\ncommitment key using in TIPP\nWrites the proof into the provided buffer.\nWrites the agggregated proof into the provided buffer.\nWrites the  proof into the provided buffer.\nWrites the  proof into the provided buffer.\nExtend by concatenating <code>other</code>. If <code>is_input_density</code> is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe <code>Comparable</code> trait allows comparison of two constraint …\nSupport for efficiently generating R1CS witness using …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConstraint system for testing purposes.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA <code>ConstraintSystem</code> which calculates witness values for a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")